# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from .types.get_agents_response import GetAgentsResponse
from ..core.pydantic_utilities import parse_obj_as
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.agent_summary import AgentSummary
from ..core.jsonable_encoder import jsonable_encoder
from ..voices.types.voice_id import VoiceId
from .types.get_templates_response import GetTemplatesResponse
from ..core.pagination import SyncPager
from .types.agent_call import AgentCall
from .types.get_calls_response import GetCallsResponse
from .types.phone_number import PhoneNumber
from .types.list_metrics_response import ListMetricsResponse
from .types.metric import Metric
from .types.metric_result import MetricResult
from .types.list_metric_results_response import ListMetricResultsResponse
from .types.deployment import Deployment
from ..core.client_wrapper import AsyncClientWrapper
from ..core.pagination import AsyncPager

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AgentsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> GetAgentsResponse:
        """
        Lists all agents associated with your account.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetAgentsResponse

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetAgentsResponse,
                    parse_obj_as(
                        type_=GetAgentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> AgentSummary:
        """
        Returns the details of a specific agent. To create an agent, use the CLI or the Playground for the best experience and integration with Github.

        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentSummary

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.get(
            agent_id="agent_123",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AgentSummary,
                    parse_obj_as(
                        type_=AgentSummary,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        agent_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        tts_voice: typing.Optional[VoiceId] = OMIT,
        tts_language: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentSummary:
        """
        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        name : typing.Optional[str]
            The name of the agent.

        description : typing.Optional[str]
            The description of the agent.

        tts_voice : typing.Optional[VoiceId]
            The voice to use for text-to-speech.

        tts_language : typing.Optional[str]
            The language to use for text-to-speech.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentSummary

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.update(
            agent_id="agent_123",
            tts_voice="bf0a246a-8642-498a-9950-80c35e9276b5",
            tts_language="en",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "tts_voice": tts_voice,
                "tts_language": tts_language,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AgentSummary,
                    parse_obj_as(
                        type_=AgentSummary,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.delete(
            agent_id="agent_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def templates(self, *, request_options: typing.Optional[RequestOptions] = None) -> GetTemplatesResponse:
        """
        List of public, Cartesia-provided agent templates to help you get started.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTemplatesResponse

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.templates()
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/templates",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetTemplatesResponse,
                    parse_obj_as(
                        type_=GetTemplatesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_calls(
        self,
        *,
        agent_id: str,
        expand: typing.Optional[str] = None,
        starting_after: typing.Optional[str] = None,
        ending_before: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[AgentCall]:
        """
        Lists calls sorted by start time in descending order for a specific agent. `agent_id` is required and if you want to include `transcript` in the response, add `expand=transcript` to the request. This endpoint is paginated.

        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        expand : typing.Optional[str]
            The fields to expand in the response. Currently, the only supported value is `transcript`.

        starting_after : typing.Optional[str]
            (Pagination option)The ID of the call to start after.

        ending_before : typing.Optional[str]
            (Pagination option) The ID of the call to end before.

        limit : typing.Optional[int]
            (Pagination option) The number of calls to return per page, ranging between 1 and 100.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[AgentCall]

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        response = client.agents.list_calls(
            agent_id="agent_id",
        )
        for item in response:
            yield item
        # alternatively, you can paginate page-by-page
        for page in response.iter_pages():
            yield page
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/calls",
            method="GET",
            params={
                "agent_id": agent_id,
                "expand": expand,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    GetCallsResponse,
                    parse_obj_as(
                        type_=GetCallsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _parsed_next = _parsed_response.next_page
                _has_next = _parsed_next is not None and _parsed_next != ""
                _get_next = lambda: self.list_calls(
                    agent_id=agent_id,
                    expand=expand,
                    starting_after=_parsed_next,
                    ending_before=ending_before,
                    limit=limit,
                    request_options=request_options,
                )
                _items = _parsed_response.data
                return SyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_call(self, call_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> AgentCall:
        """
        Parameters
        ----------
        call_id : str
            The ID of the call.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentCall

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.get_call(
            call_id="ac_abc123",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/calls/{jsonable_encoder(call_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AgentCall,
                    parse_obj_as(
                        type_=AgentCall,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def download_call_audio(
        self, call_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Iterator[bytes]:
        """
        The downloaded audio file is in .wav format. This endpoint streams the audio file content (WAV format) to the client.

        Parameters
        ----------
        call_id : str
            The ID of the call.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.Iterator[bytes]
        """
        with self._client_wrapper.httpx_client.stream(
            f"agents/calls/{jsonable_encoder(call_id)}/audio",
            method="GET",
            request_options=request_options,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                    for _chunk in _response.iter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                _response.read()
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def phone_numbers(
        self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[PhoneNumber]:
        """
        List the phone numbers associated with an agent. Currently, you can only have one phone number per agent and these are provisioned by Cartesia.

        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PhoneNumber]

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.phone_numbers(
            agent_id="agent_demo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}/phone-numbers",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PhoneNumber],
                    parse_obj_as(
                        type_=typing.List[PhoneNumber],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_metrics(
        self,
        *,
        starting_after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListMetricsResponse:
        """
        List of all LLM-as-a-Judge metrics owned by your account.

        Parameters
        ----------
        starting_after : typing.Optional[str]
            (Pagination option) The ID of the last Metric in the current response as a cursor for the next page of results.

        limit : typing.Optional[int]
            (Pagination option) The number of metrics to return per page, ranging between 1 and 100. The default page limit is 10.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListMetricsResponse

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.list_metrics()
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/metrics",
            method="GET",
            params={
                "starting_after": starting_after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListMetricsResponse,
                    parse_obj_as(
                        type_=ListMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_metric(self, metric_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> Metric:
        """
        Get a metric by its ID.

        Parameters
        ----------
        metric_id : str
            The ID of the metric.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Metric

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.get_metric(
            metric_id="am_abc123",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/metrics/{jsonable_encoder(metric_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Metric,
                    parse_obj_as(
                        type_=Metric,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_metric(
        self,
        *,
        name: str,
        prompt: str,
        display_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Metric:
        """
        Create a new metric.

        Parameters
        ----------
        name : str
            The name of the metric. This must be a unique name that only allows lower case letters, numbers, and the characters _, -, and .

        prompt : str
            The prompt associated with the metric, detailing the task and evaluation criteria.

        display_name : typing.Optional[str]
            The display name of the metric.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Metric

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.create_metric(
            name="evaluate-user-satisfaction",
            display_name="Evaluate User Satisfaction",
            prompt="Task:\nEvaluate how engaged and satisfied the user is with the conversation. Engagement may be shown through active interest in the agent’s products/services, expressing that the agent was helpful, or indicating they would want to interact again.\n\nDecision Logic:\n- If the user shows strong engagement (asks detailed follow-up questions, expresses high interest, compliments the agent, or states they would use the service/agent again) → classify as HIGH_SATISFACTION\n- If the user shows some engagement (asks a few relevant questions, shows mild interest, or gives neutral feedback) → classify as MEDIUM_SATISFACTION\n- If the user shows little or no engagement (short answers, off-topic responses, disinterest, no signs of satisfaction) → classify as LOW_SATISFACTION\n\nNotes:\n- Engagement can be verbal (explicit statements of interest) or behavioral (asking more about features, prices, benefits, or next steps).\n- Expressions of satisfaction, gratitude, or willingness to call again count as positive engagement.\n- Ignore scripted greetings or polite closings unless they contain genuine feedback.\n\nReturn:\nOnly output the exact category name as a string: HIGH_SATISFACTION, MEDIUM_SATISFACTION, or LOW_SATISFACTION.\n",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/metrics",
            method="POST",
            json={
                "name": name,
                "display_name": display_name,
                "prompt": prompt,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Metric,
                    parse_obj_as(
                        type_=Metric,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_metric_results(
        self,
        *,
        agent_id: typing.Optional[str] = None,
        deployment_id: typing.Optional[str] = None,
        metric_id: typing.Optional[str] = None,
        call_id: typing.Optional[str] = None,
        starting_after: typing.Optional[str] = None,
        ending_before: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[MetricResult]:
        """
        Paginated list of metric results. Filter results using the query parameters,

        Parameters
        ----------
        agent_id : typing.Optional[str]
            The ID of the agent.

        deployment_id : typing.Optional[str]
            The ID of the deployment.

        metric_id : typing.Optional[str]
            The ID of the metric.

        call_id : typing.Optional[str]
            The ID of the call.

        starting_after : typing.Optional[str]
            A cursor to use in pagination. `starting_after` is a metric result ID that defines your place in the list. For example, if you make a /metrics/results request and receive 100 objects, ending with `metric_result_abc123`, your subsequent call can include `starting_after=metric_result_abc123` to fetch the next page of the list.

        ending_before : typing.Optional[str]
            A cursor to use in pagination. `ending_before` is a metric result ID that defines your place in the list. For example, if you make a /metrics/results request and receive 100 objects, starting with `metric_result_abc123`, your subsequent call can include `ending_before=metric_result_abc123` to fetch the previous page of the list.

        limit : typing.Optional[int]
            The number of metric results to return per page, ranging between 1 and 100.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[MetricResult]

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        response = client.agents.list_metric_results()
        for item in response:
            yield item
        # alternatively, you can paginate page-by-page
        for page in response.iter_pages():
            yield page
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/metrics/results",
            method="GET",
            params={
                "agent_id": agent_id,
                "deployment_id": deployment_id,
                "metric_id": metric_id,
                "call_id": call_id,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    ListMetricResultsResponse,
                    parse_obj_as(
                        type_=ListMetricResultsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _parsed_next = _parsed_response.next_page
                _has_next = _parsed_next is not None and _parsed_next != ""
                _get_next = lambda: self.list_metric_results(
                    agent_id=agent_id,
                    deployment_id=deployment_id,
                    metric_id=metric_id,
                    call_id=call_id,
                    starting_after=_parsed_next,
                    ending_before=ending_before,
                    limit=limit,
                    request_options=request_options,
                )
                _items = _parsed_response.data
                return SyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def export_metric_results(
        self,
        *,
        agent_id: typing.Optional[str] = None,
        deployment_id: typing.Optional[str] = None,
        metric_id: typing.Optional[str] = None,
        call_id: typing.Optional[str] = None,
        starting_after: typing.Optional[str] = None,
        ending_before: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Export metric results to a CSV file. This endpoint is paginated with a default of 10 results per page and maximum of 100 results per page. Information on pagination can be found in the headers `x-has-more`, `x-limit`, and `x-next-page`.

        Parameters
        ----------
        agent_id : typing.Optional[str]
            The ID of the agent.

        deployment_id : typing.Optional[str]
            The ID of the deployment.

        metric_id : typing.Optional[str]
            The ID of the metric.

        call_id : typing.Optional[str]
            The ID of the call.

        starting_after : typing.Optional[str]
            A cursor to use in pagination. `starting_after` is a metric result ID that defines your place in the list. For example, if you make a /metrics/results request and receive 100 objects, ending with `metric_result_abc123`, your subsequent call can include `starting_after=metric_result_abc123` to fetch the next page of the list.

        ending_before : typing.Optional[str]
            A cursor to use in pagination. `ending_before` is a metric result ID that defines your place in the list. For example, if you make a /metrics/results request and receive 100 objects, starting with `metric_result_abc123`, your subsequent call can include `ending_before=metric_result_abc123` to fetch the previous page of the list.

        limit : typing.Optional[int]
            The number of metric results to return per page, ranging between 1 and 100.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.export_metric_results()
        """
        _response = self._client_wrapper.httpx_client.request(
            "agents/metrics/results/export",
            method="GET",
            params={
                "agent_id": agent_id,
                "deployment_id": deployment_id,
                "metric_id": metric_id,
                "call_id": call_id,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_metric_to_agent(
        self, agent_id: str, metric_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Add a metric to an agent. Once the metric is added, it will be run on all calls made to the agent automatically from that point onwards.

        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        metric_id : str
            The ID of the metric.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.add_metric_to_agent(
            agent_id="agent_id",
            metric_id="metric_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}/metrics/{jsonable_encoder(metric_id)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove_metric_from_agent(
        self, agent_id: str, metric_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Remove a metric from an agent. Once the metric is removed, it will no longer be run on all calls made to the agent automatically from that point onwards. Existing metric results will remain.

        Parameters
        ----------
        agent_id : str

        metric_id : str
            The ID of the metric.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.remove_metric_from_agent(
            agent_id="agent_id",
            metric_id="metric_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}/metrics/{jsonable_encoder(metric_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_deployments(
        self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Deployment]:
        """
        List of all deployments associated with an agent.

        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Deployment]

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.list_deployments(
            agent_id="agent_demo",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}/deployments",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Deployment],
                    parse_obj_as(
                        type_=typing.List[Deployment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_deployment(
        self, deployment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Deployment:
        """
        Get a deployment by its ID.

        Parameters
        ----------
        deployment_id : str
            The ID of the deployment.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Deployment

        Examples
        --------
        from cartesia import Cartesia

        client = Cartesia(
            token="YOUR_TOKEN",
        )
        client.agents.get_deployment(
            deployment_id="ad_abc123",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"agents/deployments/{jsonable_encoder(deployment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Deployment,
                    parse_obj_as(
                        type_=Deployment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAgentsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> GetAgentsResponse:
        """
        Lists all agents associated with your account.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetAgentsResponse

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.list()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetAgentsResponse,
                    parse_obj_as(
                        type_=GetAgentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> AgentSummary:
        """
        Returns the details of a specific agent. To create an agent, use the CLI or the Playground for the best experience and integration with Github.

        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentSummary

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.get(
                agent_id="agent_123",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AgentSummary,
                    parse_obj_as(
                        type_=AgentSummary,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        agent_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        tts_voice: typing.Optional[VoiceId] = OMIT,
        tts_language: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AgentSummary:
        """
        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        name : typing.Optional[str]
            The name of the agent.

        description : typing.Optional[str]
            The description of the agent.

        tts_voice : typing.Optional[VoiceId]
            The voice to use for text-to-speech.

        tts_language : typing.Optional[str]
            The language to use for text-to-speech.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentSummary

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.update(
                agent_id="agent_123",
                tts_voice="bf0a246a-8642-498a-9950-80c35e9276b5",
                tts_language="en",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}",
            method="PATCH",
            json={
                "name": name,
                "description": description,
                "tts_voice": tts_voice,
                "tts_language": tts_language,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AgentSummary,
                    parse_obj_as(
                        type_=AgentSummary,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.delete(
                agent_id="agent_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def templates(self, *, request_options: typing.Optional[RequestOptions] = None) -> GetTemplatesResponse:
        """
        List of public, Cartesia-provided agent templates to help you get started.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetTemplatesResponse

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.templates()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/templates",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetTemplatesResponse,
                    parse_obj_as(
                        type_=GetTemplatesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_calls(
        self,
        *,
        agent_id: str,
        expand: typing.Optional[str] = None,
        starting_after: typing.Optional[str] = None,
        ending_before: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[AgentCall]:
        """
        Lists calls sorted by start time in descending order for a specific agent. `agent_id` is required and if you want to include `transcript` in the response, add `expand=transcript` to the request. This endpoint is paginated.

        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        expand : typing.Optional[str]
            The fields to expand in the response. Currently, the only supported value is `transcript`.

        starting_after : typing.Optional[str]
            (Pagination option)The ID of the call to start after.

        ending_before : typing.Optional[str]
            (Pagination option) The ID of the call to end before.

        limit : typing.Optional[int]
            (Pagination option) The number of calls to return per page, ranging between 1 and 100.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[AgentCall]

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            response = await client.agents.list_calls(
                agent_id="agent_id",
            )
            async for item in response:
                yield item
            # alternatively, you can paginate page-by-page
            async for page in response.iter_pages():
                yield page


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/calls",
            method="GET",
            params={
                "agent_id": agent_id,
                "expand": expand,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    GetCallsResponse,
                    parse_obj_as(
                        type_=GetCallsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _parsed_next = _parsed_response.next_page
                _has_next = _parsed_next is not None and _parsed_next != ""
                _get_next = lambda: self.list_calls(
                    agent_id=agent_id,
                    expand=expand,
                    starting_after=_parsed_next,
                    ending_before=ending_before,
                    limit=limit,
                    request_options=request_options,
                )
                _items = _parsed_response.data
                return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_call(self, call_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> AgentCall:
        """
        Parameters
        ----------
        call_id : str
            The ID of the call.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AgentCall

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.get_call(
                call_id="ac_abc123",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/calls/{jsonable_encoder(call_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    AgentCall,
                    parse_obj_as(
                        type_=AgentCall,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def download_call_audio(
        self, call_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.AsyncIterator[bytes]:
        """
        The downloaded audio file is in .wav format. This endpoint streams the audio file content (WAV format) to the client.

        Parameters
        ----------
        call_id : str
            The ID of the call.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.AsyncIterator[bytes]
        """
        async with self._client_wrapper.httpx_client.stream(
            f"agents/calls/{jsonable_encoder(call_id)}/audio",
            method="GET",
            request_options=request_options,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                    async for _chunk in _response.aiter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                await _response.aread()
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def phone_numbers(
        self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[PhoneNumber]:
        """
        List the phone numbers associated with an agent. Currently, you can only have one phone number per agent and these are provisioned by Cartesia.

        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[PhoneNumber]

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.phone_numbers(
                agent_id="agent_demo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}/phone-numbers",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[PhoneNumber],
                    parse_obj_as(
                        type_=typing.List[PhoneNumber],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_metrics(
        self,
        *,
        starting_after: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListMetricsResponse:
        """
        List of all LLM-as-a-Judge metrics owned by your account.

        Parameters
        ----------
        starting_after : typing.Optional[str]
            (Pagination option) The ID of the last Metric in the current response as a cursor for the next page of results.

        limit : typing.Optional[int]
            (Pagination option) The number of metrics to return per page, ranging between 1 and 100. The default page limit is 10.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListMetricsResponse

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.list_metrics()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/metrics",
            method="GET",
            params={
                "starting_after": starting_after,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListMetricsResponse,
                    parse_obj_as(
                        type_=ListMetricsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_metric(self, metric_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> Metric:
        """
        Get a metric by its ID.

        Parameters
        ----------
        metric_id : str
            The ID of the metric.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Metric

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.get_metric(
                metric_id="am_abc123",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/metrics/{jsonable_encoder(metric_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Metric,
                    parse_obj_as(
                        type_=Metric,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_metric(
        self,
        *,
        name: str,
        prompt: str,
        display_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Metric:
        """
        Create a new metric.

        Parameters
        ----------
        name : str
            The name of the metric. This must be a unique name that only allows lower case letters, numbers, and the characters _, -, and .

        prompt : str
            The prompt associated with the metric, detailing the task and evaluation criteria.

        display_name : typing.Optional[str]
            The display name of the metric.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Metric

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.create_metric(
                name="evaluate-user-satisfaction",
                display_name="Evaluate User Satisfaction",
                prompt="Task:\nEvaluate how engaged and satisfied the user is with the conversation. Engagement may be shown through active interest in the agent’s products/services, expressing that the agent was helpful, or indicating they would want to interact again.\n\nDecision Logic:\n- If the user shows strong engagement (asks detailed follow-up questions, expresses high interest, compliments the agent, or states they would use the service/agent again) → classify as HIGH_SATISFACTION\n- If the user shows some engagement (asks a few relevant questions, shows mild interest, or gives neutral feedback) → classify as MEDIUM_SATISFACTION\n- If the user shows little or no engagement (short answers, off-topic responses, disinterest, no signs of satisfaction) → classify as LOW_SATISFACTION\n\nNotes:\n- Engagement can be verbal (explicit statements of interest) or behavioral (asking more about features, prices, benefits, or next steps).\n- Expressions of satisfaction, gratitude, or willingness to call again count as positive engagement.\n- Ignore scripted greetings or polite closings unless they contain genuine feedback.\n\nReturn:\nOnly output the exact category name as a string: HIGH_SATISFACTION, MEDIUM_SATISFACTION, or LOW_SATISFACTION.\n",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/metrics",
            method="POST",
            json={
                "name": name,
                "display_name": display_name,
                "prompt": prompt,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Metric,
                    parse_obj_as(
                        type_=Metric,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_metric_results(
        self,
        *,
        agent_id: typing.Optional[str] = None,
        deployment_id: typing.Optional[str] = None,
        metric_id: typing.Optional[str] = None,
        call_id: typing.Optional[str] = None,
        starting_after: typing.Optional[str] = None,
        ending_before: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[MetricResult]:
        """
        Paginated list of metric results. Filter results using the query parameters,

        Parameters
        ----------
        agent_id : typing.Optional[str]
            The ID of the agent.

        deployment_id : typing.Optional[str]
            The ID of the deployment.

        metric_id : typing.Optional[str]
            The ID of the metric.

        call_id : typing.Optional[str]
            The ID of the call.

        starting_after : typing.Optional[str]
            A cursor to use in pagination. `starting_after` is a metric result ID that defines your place in the list. For example, if you make a /metrics/results request and receive 100 objects, ending with `metric_result_abc123`, your subsequent call can include `starting_after=metric_result_abc123` to fetch the next page of the list.

        ending_before : typing.Optional[str]
            A cursor to use in pagination. `ending_before` is a metric result ID that defines your place in the list. For example, if you make a /metrics/results request and receive 100 objects, starting with `metric_result_abc123`, your subsequent call can include `ending_before=metric_result_abc123` to fetch the previous page of the list.

        limit : typing.Optional[int]
            The number of metric results to return per page, ranging between 1 and 100.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[MetricResult]

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            response = await client.agents.list_metric_results()
            async for item in response:
                yield item
            # alternatively, you can paginate page-by-page
            async for page in response.iter_pages():
                yield page


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/metrics/results",
            method="GET",
            params={
                "agent_id": agent_id,
                "deployment_id": deployment_id,
                "metric_id": metric_id,
                "call_id": call_id,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    ListMetricResultsResponse,
                    parse_obj_as(
                        type_=ListMetricResultsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _parsed_next = _parsed_response.next_page
                _has_next = _parsed_next is not None and _parsed_next != ""
                _get_next = lambda: self.list_metric_results(
                    agent_id=agent_id,
                    deployment_id=deployment_id,
                    metric_id=metric_id,
                    call_id=call_id,
                    starting_after=_parsed_next,
                    ending_before=ending_before,
                    limit=limit,
                    request_options=request_options,
                )
                _items = _parsed_response.data
                return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def export_metric_results(
        self,
        *,
        agent_id: typing.Optional[str] = None,
        deployment_id: typing.Optional[str] = None,
        metric_id: typing.Optional[str] = None,
        call_id: typing.Optional[str] = None,
        starting_after: typing.Optional[str] = None,
        ending_before: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Export metric results to a CSV file. This endpoint is paginated with a default of 10 results per page and maximum of 100 results per page. Information on pagination can be found in the headers `x-has-more`, `x-limit`, and `x-next-page`.

        Parameters
        ----------
        agent_id : typing.Optional[str]
            The ID of the agent.

        deployment_id : typing.Optional[str]
            The ID of the deployment.

        metric_id : typing.Optional[str]
            The ID of the metric.

        call_id : typing.Optional[str]
            The ID of the call.

        starting_after : typing.Optional[str]
            A cursor to use in pagination. `starting_after` is a metric result ID that defines your place in the list. For example, if you make a /metrics/results request and receive 100 objects, ending with `metric_result_abc123`, your subsequent call can include `starting_after=metric_result_abc123` to fetch the next page of the list.

        ending_before : typing.Optional[str]
            A cursor to use in pagination. `ending_before` is a metric result ID that defines your place in the list. For example, if you make a /metrics/results request and receive 100 objects, starting with `metric_result_abc123`, your subsequent call can include `ending_before=metric_result_abc123` to fetch the previous page of the list.

        limit : typing.Optional[int]
            The number of metric results to return per page, ranging between 1 and 100.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.export_metric_results()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "agents/metrics/results/export",
            method="GET",
            params={
                "agent_id": agent_id,
                "deployment_id": deployment_id,
                "metric_id": metric_id,
                "call_id": call_id,
                "starting_after": starting_after,
                "ending_before": ending_before,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_metric_to_agent(
        self, agent_id: str, metric_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Add a metric to an agent. Once the metric is added, it will be run on all calls made to the agent automatically from that point onwards.

        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        metric_id : str
            The ID of the metric.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.add_metric_to_agent(
                agent_id="agent_id",
                metric_id="metric_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}/metrics/{jsonable_encoder(metric_id)}",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove_metric_from_agent(
        self, agent_id: str, metric_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Remove a metric from an agent. Once the metric is removed, it will no longer be run on all calls made to the agent automatically from that point onwards. Existing metric results will remain.

        Parameters
        ----------
        agent_id : str

        metric_id : str
            The ID of the metric.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.remove_metric_from_agent(
                agent_id="agent_id",
                metric_id="metric_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}/metrics/{jsonable_encoder(metric_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_deployments(
        self, agent_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[Deployment]:
        """
        List of all deployments associated with an agent.

        Parameters
        ----------
        agent_id : str
            The ID of the agent.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[Deployment]

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.list_deployments(
                agent_id="agent_demo",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/{jsonable_encoder(agent_id)}/deployments",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[Deployment],
                    parse_obj_as(
                        type_=typing.List[Deployment],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_deployment(
        self, deployment_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> Deployment:
        """
        Get a deployment by its ID.

        Parameters
        ----------
        deployment_id : str
            The ID of the deployment.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Deployment

        Examples
        --------
        import asyncio

        from cartesia import AsyncCartesia

        client = AsyncCartesia(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.agents.get_deployment(
                deployment_id="ad_abc123",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"agents/deployments/{jsonable_encoder(deployment_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Deployment,
                    parse_obj_as(
                        type_=Deployment,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
